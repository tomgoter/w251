# W251 - Summer 2020
## Homework 3
## Tom Goter

This repository has all of the docker files and context files used to create five docker containers as part of homework 3. The first three docker containers are created on the Jetson device, and the second two are created in the cloud on a lightweight server. 

1. Facial Capture Container - This container is created using the FD.Dockerfile and face_detector.py file. In this container OpenCV is used to to the facial capture. Further the paho-mqtt package is used to publish messages to a topic on a local MQTT broker. The topic used is hw3_topic and each message corresponds to a cropped face. We first set up a network using the following command: `docker network create --driver bridge hw03`. Then we create our docker image using the following command:`docker build -t fdapp:v1 -f dockerfiles/FD.Dockerfile context` After this image is created, \oOne can run this container with the following command: `docker run -e DISPLAY=$DISPLAY --rm --privileged --env QT_X11_NO_MITSHM=1 -v /tmp/.X11-unix:/tmp/.X11-unix:rw --device /dev/video0 --network=hw03 -ti fdapp:v1`. If all goes well you will see a little window pop up on the display connected to your jetson with a live stream of cropped images of your face (assuming the webcam is pointed toward you).
2. Jetson MQTT Broker - Basically we need to create the MQTT broker that will receive and send messages. To do this we create a tiny docker image consisting of Alpine and mosquitto. This image is created using the following command : `docker build -t mosquitto -f dockerfile/MQQT.Dockerfile .` Once the image is created, we can start the broker by using the following command: `docker run --name=mosquitto --network hw03 -p 1883:1883 -ti --rm mosquitto`. This command will start the broker in a container named 'mosquitto' on the same local network as our first container. 
3. Jetson MQTT Message Forwarder - We create another relatively lightweight container. This one uses alpine with python and paho-mqtt in order to catch messages from the facial capture container through a topic subscription on the MQTT Broker. Everytime a message (face) is received, we customize the response such that we forward the message on to an external MQTT broker. Our docker image is created using the following command: `docker build -t forwarder -f dockerfiles/FWD.Dockerfile context`. Once this image is created, create the container using the following command: `docker run --rm --name forwarder --network=hw03 -ti forwarder`
4. IBM SoftLayer MQTT Broker - We have a 2GB RAM 2 CPU device in the cloud. We also create a new network for our docker containers using the following command: `docker network create --driver bridge hw03_cloud` On this device our first docker container is just another MQTT broker. It will receive the forwarded messages from the Jetson MQTT Broker. We actually use the exact same Docker image file (file management with Git between cloud and Jetson). We call the container mqtt_cloud in this case but you will notice the image is still mosquitto `docker build -t mosquitto -f dockerfile/MQQT.Dockerfile .` After creating the image on the cloud, we set up our broker with `docker run --name mqtt_cloud --network hw03_cloud -p 1883:1883 -ti --rm mosquitto`
5. IBM SoftLayer Image Storer - Our final docker container is used to subscribe to the images sent through our network and then write them to a shared volume that is actually our fuse-mounted S3 Object Storage location. Basically we install s3fuse on the node we are on. This allowed us to create the following directory /mnt/mybucket. This directory is then used as a shared volume with docker. So we can write data to this directory from a docker container and it ends up in the cloud. The image is a base python image with paho-mqtt installed. You can create the image with the following command: `docker build -t storage -f dockerfiles/store.Dockerfile context`. You can run the container using the next line, notice the -v option: `docker run --rm --network=hw03_cloud -ti -v/mnt/mybucket:/images storage`. And voila you should be live streaming cropped images of your dome to the cloud. I recommend killing this process after a few seconds or you will end up with a lot of images.
